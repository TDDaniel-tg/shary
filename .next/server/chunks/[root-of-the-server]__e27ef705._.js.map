{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/work/project/lib/db/index.ts"],"sourcesContent":["import fs from 'fs';\r\nimport path from 'path';\r\n\r\ninterface Product {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  price: number;\r\n  salePrice: number | null;\r\n  category: string;\r\n  stock: number;\r\n  images: string[];\r\n  featured: boolean;\r\n  published: boolean;\r\n  createdAt: string;\r\n}\r\n\r\ninterface Review {\r\n  id: string;\r\n  productId: string;\r\n  productName: string;\r\n  userName: string;\r\n  rating: number;\r\n  content: string;\r\n  status: 'pending' | 'approved' | 'rejected';\r\n  createdAt: string;\r\n}\r\n\r\ninterface DbData {\r\n  products: Product[];\r\n  reviews: Review[];\r\n}\r\n\r\n// Путь к JSON файлам\r\nconst DB_DIR = path.join(process.cwd(), 'lib', 'db');\r\nconst PRODUCTS_FILE = path.join(DB_DIR, 'products.json');\r\nconst REVIEWS_FILE = path.join(DB_DIR, 'reviews.json');\r\n\r\n// Функция для чтения данных из JSON файла\r\nexport function readJsonFile<T>(filePath: string): T {\r\n  try {\r\n    const fileContent = fs.readFileSync(filePath, 'utf8');\r\n    return JSON.parse(fileContent) as T;\r\n  } catch (error) {\r\n    console.error(`Error reading file ${filePath}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Функция для записи данных в JSON файл\r\nexport function writeJsonFile<T>(filePath: string, data: T): void {\r\n  try {\r\n    const jsonString = JSON.stringify(data, null, 2);\r\n    fs.writeFileSync(filePath, jsonString, 'utf8');\r\n  } catch (error) {\r\n    console.error(`Error writing to file ${filePath}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Функции для работы с товарами\r\nexport function getAllProducts(): Product[] {\r\n  const data = readJsonFile<{ products: Product[] }>(PRODUCTS_FILE);\r\n  return data.products;\r\n}\r\n\r\nexport function getProductById(id: string): Product | null {\r\n  const products = getAllProducts();\r\n  return products.find(product => product.id === id) || null;\r\n}\r\n\r\nexport function createProduct(product: Omit<Product, 'id' | 'createdAt'>): Product {\r\n  const products = getAllProducts();\r\n  const newId = (Math.max(...products.map(p => parseInt(p.id)), 0) + 1).toString();\r\n  \r\n  const newProduct: Product = {\r\n    ...product,\r\n    id: newId,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  \r\n  products.push(newProduct);\r\n  writeJsonFile(PRODUCTS_FILE, { products });\r\n  \r\n  return newProduct;\r\n}\r\n\r\nexport function updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt'>>): Product | null {\r\n  const products = getAllProducts();\r\n  const productIndex = products.findIndex(p => p.id === id);\r\n  \r\n  if (productIndex === -1) {\r\n    return null;\r\n  }\r\n  \r\n  const updatedProduct = {\r\n    ...products[productIndex],\r\n    ...updates\r\n  };\r\n  \r\n  products[productIndex] = updatedProduct;\r\n  writeJsonFile(PRODUCTS_FILE, { products });\r\n  \r\n  return updatedProduct;\r\n}\r\n\r\nexport function deleteProduct(id: string): boolean {\r\n  const products = getAllProducts();\r\n  const productIndex = products.findIndex(p => p.id === id);\r\n  \r\n  if (productIndex === -1) {\r\n    return false;\r\n  }\r\n  \r\n  products.splice(productIndex, 1);\r\n  writeJsonFile(PRODUCTS_FILE, { products });\r\n  \r\n  return true;\r\n}\r\n\r\n// Функции для работы с отзывами\r\nexport function getAllReviews(): Review[] {\r\n  const data = readJsonFile<{ reviews: Review[] }>(REVIEWS_FILE);\r\n  return data.reviews;\r\n}\r\n\r\nexport function getReviewsByStatus(status: 'pending' | 'approved' | 'rejected'): Review[] {\r\n  const reviews = getAllReviews();\r\n  return reviews.filter(review => review.status === status);\r\n}\r\n\r\nexport function getReviewById(id: string): Review | null {\r\n  const reviews = getAllReviews();\r\n  return reviews.find(review => review.id === id) || null;\r\n}\r\n\r\nexport function updateReviewStatus(id: string, status: 'pending' | 'approved' | 'rejected'): Review | null {\r\n  const reviews = getAllReviews();\r\n  const reviewIndex = reviews.findIndex(r => r.id === id);\r\n  \r\n  if (reviewIndex === -1) {\r\n    return null;\r\n  }\r\n  \r\n  reviews[reviewIndex].status = status;\r\n  writeJsonFile(REVIEWS_FILE, { reviews });\r\n  \r\n  return reviews[reviewIndex];\r\n}\r\n\r\nexport function createReview(review: Omit<Review, 'id' | 'createdAt' | 'status'>): Review {\r\n  const reviews = getAllReviews();\r\n  const newId = (Math.max(...reviews.map(r => parseInt(r.id)), 0) + 1).toString();\r\n  \r\n  const newReview: Review = {\r\n    ...review,\r\n    id: newId,\r\n    status: 'pending',\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  \r\n  reviews.push(newReview);\r\n  writeJsonFile(REVIEWS_FILE, { reviews });\r\n  \r\n  return newReview;\r\n}\r\n\r\nexport function deleteReview(id: string): boolean {\r\n  const reviews = getAllReviews();\r\n  const reviewIndex = reviews.findIndex(r => r.id === id);\r\n  \r\n  if (reviewIndex === -1) {\r\n    return false;\r\n  }\r\n  \r\n  reviews.splice(reviewIndex, 1);\r\n  writeJsonFile(REVIEWS_FILE, { reviews });\r\n  \r\n  return true;\r\n}\r\n\r\n// Экспортируем типы\r\nexport type { Product, Review }; "],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;;;AAgCA,qBAAqB;AACrB,MAAM,SAAS,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,OAAO;AAC/C,MAAM,gBAAgB,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ;AACxC,MAAM,eAAe,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ;AAGhC,SAAS,aAAgB,QAAgB;IAC9C,IAAI;QACF,MAAM,cAAc,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,UAAU;QAC9C,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC,EAAE;QACjD,MAAM;IACR;AACF;AAGO,SAAS,cAAiB,QAAgB,EAAE,IAAO;IACxD,IAAI;QACF,MAAM,aAAa,KAAK,SAAS,CAAC,MAAM,MAAM;QAC9C,6FAAA,CAAA,UAAE,CAAC,aAAa,CAAC,UAAU,YAAY;IACzC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,sBAAsB,EAAE,SAAS,CAAC,CAAC,EAAE;QACpD,MAAM;IACR;AACF;AAGO,SAAS;IACd,MAAM,OAAO,aAAsC;IACnD,OAAO,KAAK,QAAQ;AACtB;AAEO,SAAS,eAAe,EAAU;IACvC,MAAM,WAAW;IACjB,OAAO,SAAS,IAAI,CAAC,CAAA,UAAW,QAAQ,EAAE,KAAK,OAAO;AACxD;AAEO,SAAS,cAAc,OAA0C;IACtE,MAAM,WAAW;IACjB,MAAM,QAAQ,CAAC,KAAK,GAAG,IAAI,SAAS,GAAG,CAAC,CAAA,IAAK,SAAS,EAAE,EAAE,IAAI,KAAK,CAAC,EAAE,QAAQ;IAE9E,MAAM,aAAsB;QAC1B,GAAG,OAAO;QACV,IAAI;QACJ,WAAW,IAAI,OAAO,WAAW;IACnC;IAEA,SAAS,IAAI,CAAC;IACd,cAAc,eAAe;QAAE;IAAS;IAExC,OAAO;AACT;AAEO,SAAS,cAAc,EAAU,EAAE,OAAmD;IAC3F,MAAM,WAAW;IACjB,MAAM,eAAe,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAEtD,IAAI,iBAAiB,CAAC,GAAG;QACvB,OAAO;IACT;IAEA,MAAM,iBAAiB;QACrB,GAAG,QAAQ,CAAC,aAAa;QACzB,GAAG,OAAO;IACZ;IAEA,QAAQ,CAAC,aAAa,GAAG;IACzB,cAAc,eAAe;QAAE;IAAS;IAExC,OAAO;AACT;AAEO,SAAS,cAAc,EAAU;IACtC,MAAM,WAAW;IACjB,MAAM,eAAe,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAEtD,IAAI,iBAAiB,CAAC,GAAG;QACvB,OAAO;IACT;IAEA,SAAS,MAAM,CAAC,cAAc;IAC9B,cAAc,eAAe;QAAE;IAAS;IAExC,OAAO;AACT;AAGO,SAAS;IACd,MAAM,OAAO,aAAoC;IACjD,OAAO,KAAK,OAAO;AACrB;AAEO,SAAS,mBAAmB,MAA2C;IAC5E,MAAM,UAAU;IAChB,OAAO,QAAQ,MAAM,CAAC,CAAA,SAAU,OAAO,MAAM,KAAK;AACpD;AAEO,SAAS,cAAc,EAAU;IACtC,MAAM,UAAU;IAChB,OAAO,QAAQ,IAAI,CAAC,CAAA,SAAU,OAAO,EAAE,KAAK,OAAO;AACrD;AAEO,SAAS,mBAAmB,EAAU,EAAE,MAA2C;IACxF,MAAM,UAAU;IAChB,MAAM,cAAc,QAAQ,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAEpD,IAAI,gBAAgB,CAAC,GAAG;QACtB,OAAO;IACT;IAEA,OAAO,CAAC,YAAY,CAAC,MAAM,GAAG;IAC9B,cAAc,cAAc;QAAE;IAAQ;IAEtC,OAAO,OAAO,CAAC,YAAY;AAC7B;AAEO,SAAS,aAAa,MAAmD;IAC9E,MAAM,UAAU;IAChB,MAAM,QAAQ,CAAC,KAAK,GAAG,IAAI,QAAQ,GAAG,CAAC,CAAA,IAAK,SAAS,EAAE,EAAE,IAAI,KAAK,CAAC,EAAE,QAAQ;IAE7E,MAAM,YAAoB;QACxB,GAAG,MAAM;QACT,IAAI;QACJ,QAAQ;QACR,WAAW,IAAI,OAAO,WAAW;IACnC;IAEA,QAAQ,IAAI,CAAC;IACb,cAAc,cAAc;QAAE;IAAQ;IAEtC,OAAO;AACT;AAEO,SAAS,aAAa,EAAU;IACrC,MAAM,UAAU;IAChB,MAAM,cAAc,QAAQ,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAEpD,IAAI,gBAAgB,CAAC,GAAG;QACtB,OAAO;IACT;IAEA,QAAQ,MAAM,CAAC,aAAa;IAC5B,cAAc,cAAc;QAAE;IAAQ;IAEtC,OAAO;AACT","debugId":null}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/work/project/app/api/admin/products/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { ProductModel } from '@/lib/models/Product';\r\nimport jwt from 'jsonwebtoken';\r\nimport { writeFile, mkdir } from 'fs/promises';\r\nimport { join } from 'path';\r\nimport { existsSync } from 'fs';\r\nimport { getAllProducts, createProduct, deleteProduct } from '@/lib/db';\r\nimport type { Product } from '@/lib/db';\r\n\r\n// Проверка авторизации админа\r\nfunction verifyAdminToken(request: NextRequest | Request) {\r\n  const authorization = request.headers.get('authorization') || request.headers.get('Authorization');\r\n  if (!authorization || !authorization.startsWith('Bearer ')) {\r\n    return null;\r\n  }\r\n\r\n  const token = authorization.replace('Bearer ', '');\r\n  \r\n  try {\r\n    // В реальном приложении здесь должна быть проверка JWT\r\n    // Для демонстрации считаем, что любой непустой токен действителен\r\n    if (token.length > 0) {\r\n      return { role: 'admin' };\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Функция для сохранения изображения\r\nasync function saveImage(file: File): Promise<string> {\r\n  const bytes = await file.arrayBuffer();\r\n  const buffer = Buffer.from(bytes);\r\n\r\n  // Создаем уникальное имя файла\r\n  const fileName = `${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '')}`;\r\n  const uploadDir = join(process.cwd(), 'public', 'images', 'products');\r\n  \r\n  // Создаем директорию если не существует\r\n  if (!existsSync(uploadDir)) {\r\n    await mkdir(uploadDir, { recursive: true });\r\n  }\r\n\r\n  const filePath = join(uploadDir, fileName);\r\n  await writeFile(filePath, buffer);\r\n\r\n  return `/images/products/${fileName}`;\r\n}\r\n\r\n// Получение всех товаров и создание нового товара\r\nexport async function GET(request: NextRequest | Request) {\r\n  try {\r\n    // Проверка авторизации\r\n    const adminUser = verifyAdminToken(request);\r\n    if (!adminUser) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Используем новую функцию для получения товаров из JSON файла\r\n    const products = getAllProducts();\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: products,\r\n      count: products.length\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching products:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to fetch products' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// Создание товара\r\nexport async function POST(request: NextRequest | Request) {\r\n  try {\r\n    // Проверка авторизации\r\n    const adminUser = verifyAdminToken(request);\r\n    if (!adminUser) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const formData = await request.formData();\r\n    \r\n    // Извлекаем базовые данные из FormData\r\n    const name = formData.get('name') as string;\r\n    const description = formData.get('description') as string;\r\n    const priceStr = formData.get('price') as string;\r\n    const salePriceStr = formData.get('salePrice') as string || formData.get('original_price') as string;\r\n    const category = formData.get('category') as string || formData.get('category_id') as string;\r\n    const stockStr = formData.get('stock') as string || formData.get('stock_quantity') as string;\r\n    const featured = formData.get('featured') === 'true' || formData.get('is_featured') === 'true';\r\n    const published = formData.get('published') === 'true' || true;\r\n    \r\n    // Парсим числовые значения\r\n    const price = parseFloat(priceStr);\r\n    const salePrice = salePriceStr ? parseFloat(salePriceStr) : null;\r\n    const stock = parseInt(stockStr);\r\n    \r\n    // Валидация обязательных полей\r\n    if (!name || !description || isNaN(price) || !category || isNaN(stock) || stock < 0) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Missing or invalid required fields' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Обработка изображения\r\n    let images = ['/images/products/placeholder.jpg']; // по умолчанию\r\n    const imageFile = formData.get('image') as File;\r\n    if (imageFile && imageFile.size > 0) {\r\n      const imagePath = await saveImage(imageFile);\r\n      images = [imagePath];\r\n    }\r\n\r\n    // Создаем новый товар используя новую функцию из lib/db\r\n    const newProduct = createProduct({\r\n      name,\r\n      description,\r\n      price,\r\n      salePrice,\r\n      category,\r\n      stock,\r\n      images,\r\n      featured,\r\n      published\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: newProduct\r\n    }, { status: 201 });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to create product' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}}]
}